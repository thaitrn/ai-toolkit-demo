---
description: 
globs: 
alwaysApply: true
---

# Error Handling Standards

## Exception Hierarchy

```
BusinessException (abstract)
├── ValidationException
├── NotFoundException
├── DuplicateException
├── UnauthorizedException
├── ForbiddenException
└── IntegrationException
    ├── ServiceUnavailableException
    └── TimeoutException
```

## Base Exception Class

```java
@Getter
public abstract class BusinessException extends RuntimeException {
    private final String errorCode;
    private final HttpStatus httpStatus;
    
    protected BusinessException(String message, String errorCode, HttpStatus httpStatus) {
        super(message);
        this.errorCode = errorCode;
        this.httpStatus = httpStatus;
    }
}
```

## Common Exceptions

```java
public class NotFoundException extends BusinessException {
    public NotFoundException(String message) {
        super(message, "NOT_FOUND", HttpStatus.NOT_FOUND);
    }
    
    public static NotFoundException forEntity(String entityName, Object id) {
        return new NotFoundException(
            String.format("%s with id '%s' not found", entityName, id)
        );
    }
}

public class ValidationException extends BusinessException {
    private final List<FieldError> fieldErrors;
    
    public ValidationException(List<FieldError> fieldErrors) {
        super("Validation failed", "VALIDATION_ERROR", HttpStatus.BAD_REQUEST);
        this.fieldErrors = fieldErrors;
    }
}
```

## Global Exception Handler

```java
@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {

    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<ErrorResponse> handleBusinessException(BusinessException ex) {
        log.error("Business exception: {}", ex.getMessage());
        
        return ResponseEntity
            .status(ex.getHttpStatus())
            .body(ErrorResponse.builder()
                .code(ex.getErrorCode())
                .message(ex.getMessage())
                .timestamp(Instant.now())
                .build());
    }
    
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidationException(
            MethodArgumentNotValidException ex) {
        
        List<FieldError> errors = ex.getBindingResult()
            .getFieldErrors()
            .stream()
            .map(e -> new FieldError(e.getField(), e.getDefaultMessage()))
            .toList();
            
        return ResponseEntity
            .badRequest()
            .body(ErrorResponse.builder()
                .code("VALIDATION_ERROR")
                .message("Validation failed")
                .errors(errors)
                .timestamp(Instant.now())
                .build());
    }
    
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGenericException(Exception ex) {
        log.error("Unexpected error", ex);
        
        return ResponseEntity
            .internalServerError()
            .body(ErrorResponse.builder()
                .code("INTERNAL_ERROR")
                .message("An unexpected error occurred")
                .timestamp(Instant.now())
                .build());
    }
}
```

## Error Response Format

```java
@Data
@Builder
public class ErrorResponse {
    private String code;
    private String message;
    private Instant timestamp;
    private List<FieldError> errors;
    private String traceId;
}

@Data
@AllArgsConstructor
public class FieldError {
    private String field;
    private String message;
}
```

## Best Practices

1. **Never expose stack traces** to clients in production
2. **Log with correlation ID** for traceability
3. **Use specific exception types** instead of generic Exception
4. **Include error codes** for client-side handling
5. **Validate early** at controller level with `@Valid`
